{"ast":null,"code":"// API Configuration\nconst API_BASE_URL = process.env.REACT_APP_API_BASE_URL || 'http://localhost:8000';\nconst WS_BASE_URL = process.env.REACT_APP_WS_BASE_URL || 'ws://localhost:8000';\n\n// Types for API communication\n\nclass APIService {\n  constructor() {\n    this.ws = null;\n    this.callbacks = null;\n    this.sessionId = null;\n    this.reconnectAttempts = 0;\n    this.maxReconnectAttempts = 5;\n  }\n  // Initialize WebSocket connection for real-time updates\n  async initializeRealTimeConnection(meetingContext, callbacks) {\n    this.callbacks = callbacks;\n    try {\n      // First, register the meeting session with REST API\n      const sessionResponse = await fetch(`${API_BASE_URL}/api/meetings/sessions`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'Authorization': `Bearer ${this.getAuthToken()}`\n        },\n        body: JSON.stringify({\n          platform: meetingContext.platform,\n          meetingId: meetingContext.id,\n          meetingType: meetingContext.type,\n          userId: this.getUserId(),\n          timestamp: Date.now()\n        })\n      });\n      if (!sessionResponse.ok) {\n        throw new Error('Failed to create meeting session');\n      }\n      const session = await sessionResponse.json();\n      this.sessionId = session.sessionId;\n\n      // Then establish WebSocket connection\n      await this.connectWebSocket(session.sessionId);\n      return session.sessionId;\n    } catch (error) {\n      var _this$callbacks;\n      console.error('Failed to initialize real-time connection:', error);\n      (_this$callbacks = this.callbacks) === null || _this$callbacks === void 0 ? void 0 : _this$callbacks.onError('Failed to connect to AI backend');\n      throw error;\n    }\n  }\n  async connectWebSocket(sessionId) {\n    return new Promise((resolve, reject) => {\n      try {\n        this.ws = new WebSocket(`${WS_BASE_URL}/ws/meetings/${sessionId}?token=${this.getAuthToken()}`);\n        this.ws.onopen = () => {\n          console.log('WebSocket connected for session:', sessionId);\n          this.reconnectAttempts = 0;\n          resolve();\n        };\n        this.ws.onmessage = event => {\n          this.handleWebSocketMessage(event);\n        };\n        this.ws.onclose = event => {\n          console.log('WebSocket closed:', event.code, event.reason);\n          this.handleWebSocketClose();\n        };\n        this.ws.onerror = error => {\n          console.error('WebSocket error:', error);\n          reject(error);\n        };\n      } catch (error) {\n        reject(error);\n      }\n    });\n  }\n  handleWebSocketMessage(event) {\n    var _this$callbacks2, _this$callbacks3, _this$callbacks4, _this$callbacks5, _this$callbacks6;\n    try {\n      const data = JSON.parse(event.data);\n      switch (data.type) {\n        case 'questions_update':\n          (_this$callbacks2 = this.callbacks) === null || _this$callbacks2 === void 0 ? void 0 : _this$callbacks2.onQuestionsUpdate(data.payload);\n          break;\n        case 'cues_update':\n          (_this$callbacks3 = this.callbacks) === null || _this$callbacks3 === void 0 ? void 0 : _this$callbacks3.onCuesUpdate(data.payload);\n          break;\n        case 'ai_suggestions_update':\n          (_this$callbacks4 = this.callbacks) === null || _this$callbacks4 === void 0 ? void 0 : _this$callbacks4.onAISuggestionsUpdate(data.payload);\n          break;\n        case 'meeting_stage_change':\n          (_this$callbacks5 = this.callbacks) === null || _this$callbacks5 === void 0 ? void 0 : _this$callbacks5.onMeetingStageChange(data.payload.stage);\n          break;\n        case 'error':\n          (_this$callbacks6 = this.callbacks) === null || _this$callbacks6 === void 0 ? void 0 : _this$callbacks6.onError(data.payload.message);\n          break;\n        default:\n          console.log('Unknown message type:', data.type);\n      }\n    } catch (error) {\n      console.error('Failed to parse WebSocket message:', error);\n    }\n  }\n  handleWebSocketClose() {\n    if (this.reconnectAttempts < this.maxReconnectAttempts) {\n      this.reconnectAttempts++;\n      const delay = Math.pow(2, this.reconnectAttempts) * 1000; // Exponential backoff\n\n      console.log(`Attempting to reconnect in ${delay}ms (attempt ${this.reconnectAttempts})`);\n      setTimeout(() => {\n        if (this.sessionId) {\n          this.connectWebSocket(this.sessionId);\n        }\n      }, delay);\n    } else {\n      var _this$callbacks7;\n      (_this$callbacks7 = this.callbacks) === null || _this$callbacks7 === void 0 ? void 0 : _this$callbacks7.onError('Lost connection to AI backend');\n    }\n  }\n\n  // Send meeting events to backend\n  async sendMeetingEvent(eventType, data) {\n    if (!this.sessionId) {\n      console.warn('No active session to send event');\n      return;\n    }\n    try {\n      // Send via WebSocket for real-time processing\n      if (this.ws && this.ws.readyState === WebSocket.OPEN) {\n        this.ws.send(JSON.stringify({\n          type: 'meeting_event',\n          sessionId: this.sessionId,\n          eventType,\n          data,\n          timestamp: Date.now()\n        }));\n      }\n\n      // Also send via REST API for reliability\n      await fetch(`${API_BASE_URL}/api/meetings/events`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'Authorization': `Bearer ${this.getAuthToken()}`\n        },\n        body: JSON.stringify({\n          sessionId: this.sessionId,\n          eventType,\n          data,\n          timestamp: Date.now()\n        })\n      });\n    } catch (error) {\n      console.error('Failed to send meeting event:', error);\n    }\n  }\n\n  // Send participant updates\n  async updateParticipants(participants) {\n    await this.sendMeetingEvent('participants_update', {\n      participants\n    });\n  }\n\n  // Send transcript/conversation updates\n  async sendTranscriptUpdate(transcript) {\n    await this.sendMeetingEvent('transcript_update', {\n      transcript\n    });\n  }\n\n  // Send user interaction events\n  async sendUserInteraction(interaction) {\n    await this.sendMeetingEvent('user_interaction', interaction);\n  }\n\n  // Close connection\n  async closeConnection() {\n    if (this.ws) {\n      this.ws.close();\n      this.ws = null;\n    }\n    if (this.sessionId) {\n      try {\n        await fetch(`${API_BASE_URL}/api/meetings/sessions/${this.sessionId}`, {\n          method: 'DELETE',\n          headers: {\n            'Authorization': `Bearer ${this.getAuthToken()}`\n          }\n        });\n      } catch (error) {\n        console.error('Failed to close session:', error);\n      }\n      this.sessionId = null;\n    }\n  }\n\n  // Helper methods\n  getAuthToken() {\n    // Get from localStorage, context, or environment\n    return localStorage.getItem('clarivue_auth_token') || 'demo-token';\n  }\n  getUserId() {\n    // Get from user context or localStorage\n    return localStorage.getItem('clarivue_user_id') || 'demo-user';\n  }\n}\nexport const apiService = new APIService();","map":{"version":3,"names":["API_BASE_URL","process","env","REACT_APP_API_BASE_URL","WS_BASE_URL","REACT_APP_WS_BASE_URL","APIService","constructor","ws","callbacks","sessionId","reconnectAttempts","maxReconnectAttempts","initializeRealTimeConnection","meetingContext","sessionResponse","fetch","method","headers","getAuthToken","body","JSON","stringify","platform","meetingId","id","meetingType","type","userId","getUserId","timestamp","Date","now","ok","Error","session","json","connectWebSocket","error","_this$callbacks","console","onError","Promise","resolve","reject","WebSocket","onopen","log","onmessage","event","handleWebSocketMessage","onclose","code","reason","handleWebSocketClose","onerror","_this$callbacks2","_this$callbacks3","_this$callbacks4","_this$callbacks5","_this$callbacks6","data","parse","onQuestionsUpdate","payload","onCuesUpdate","onAISuggestionsUpdate","onMeetingStageChange","stage","message","delay","Math","pow","setTimeout","_this$callbacks7","sendMeetingEvent","eventType","warn","readyState","OPEN","send","updateParticipants","participants","sendTranscriptUpdate","transcript","sendUserInteraction","interaction","closeConnection","close","localStorage","getItem","apiService"],"sources":["/Users/tobitowoju/clarivue-addon/clarivue-addon/src/services/apiService.ts"],"sourcesContent":["import { Question, Cue, AISuggestion, MeetingContext } from '../utils/mockData';\n\n// API Configuration\nconst API_BASE_URL = process.env.REACT_APP_API_BASE_URL || 'http://localhost:8000';\nconst WS_BASE_URL = process.env.REACT_APP_WS_BASE_URL || 'ws://localhost:8000';\n\n// Types for API communication\nexport interface MeetingSession {\n  sessionId: string;\n  platform: 'zoom' | 'teams' | 'meet';\n  meetingId: string;\n  userId: string;\n  timestamp: number;\n}\n\nexport interface LiveMeetingData {\n  questions: Question[];\n  cues: Cue[];\n  aiSuggestions: AISuggestion[];\n  meetingStage: 'start' | 'middle' | 'end';\n  participants: any[];\n  transcript?: string[];\n}\n\nexport interface APICallbacks {\n  onQuestionsUpdate: (questions: Question[]) => void;\n  onCuesUpdate: (cues: Cue[]) => void;\n  onAISuggestionsUpdate: (suggestions: AISuggestion[]) => void;\n  onMeetingStageChange: (stage: 'start' | 'middle' | 'end') => void;\n  onError: (error: string) => void;\n}\n\nclass APIService {\n  private ws: WebSocket | null = null;\n  private callbacks: APICallbacks | null = null;\n  private sessionId: string | null = null;\n  private reconnectAttempts = 0;\n  private maxReconnectAttempts = 5;\n\n  // Initialize WebSocket connection for real-time updates\n  async initializeRealTimeConnection(\n    meetingContext: MeetingContext, \n    callbacks: APICallbacks\n  ): Promise<string> {\n    this.callbacks = callbacks;\n    \n    try {\n      // First, register the meeting session with REST API\n      const sessionResponse = await fetch(`${API_BASE_URL}/api/meetings/sessions`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'Authorization': `Bearer ${this.getAuthToken()}`\n        },\n        body: JSON.stringify({\n          platform: meetingContext.platform,\n          meetingId: meetingContext.id,\n          meetingType: meetingContext.type,\n          userId: this.getUserId(),\n          timestamp: Date.now()\n        })\n      });\n\n      if (!sessionResponse.ok) {\n        throw new Error('Failed to create meeting session');\n      }\n\n      const session: MeetingSession = await sessionResponse.json();\n      this.sessionId = session.sessionId;\n\n      // Then establish WebSocket connection\n      await this.connectWebSocket(session.sessionId);\n      \n      return session.sessionId;\n    } catch (error) {\n      console.error('Failed to initialize real-time connection:', error);\n      this.callbacks?.onError('Failed to connect to AI backend');\n      throw error;\n    }\n  }\n\n  private async connectWebSocket(sessionId: string): Promise<void> {\n    return new Promise((resolve, reject) => {\n      try {\n        this.ws = new WebSocket(`${WS_BASE_URL}/ws/meetings/${sessionId}?token=${this.getAuthToken()}`);\n        \n        this.ws.onopen = () => {\n          console.log('WebSocket connected for session:', sessionId);\n          this.reconnectAttempts = 0;\n          resolve();\n        };\n\n        this.ws.onmessage = (event) => {\n          this.handleWebSocketMessage(event);\n        };\n\n        this.ws.onclose = (event) => {\n          console.log('WebSocket closed:', event.code, event.reason);\n          this.handleWebSocketClose();\n        };\n\n        this.ws.onerror = (error) => {\n          console.error('WebSocket error:', error);\n          reject(error);\n        };\n      } catch (error) {\n        reject(error);\n      }\n    });\n  }\n\n  private handleWebSocketMessage(event: MessageEvent): void {\n    try {\n      const data = JSON.parse(event.data);\n      \n      switch (data.type) {\n        case 'questions_update':\n          this.callbacks?.onQuestionsUpdate(data.payload);\n          break;\n        case 'cues_update':\n          this.callbacks?.onCuesUpdate(data.payload);\n          break;\n        case 'ai_suggestions_update':\n          this.callbacks?.onAISuggestionsUpdate(data.payload);\n          break;\n        case 'meeting_stage_change':\n          this.callbacks?.onMeetingStageChange(data.payload.stage);\n          break;\n        case 'error':\n          this.callbacks?.onError(data.payload.message);\n          break;\n        default:\n          console.log('Unknown message type:', data.type);\n      }\n    } catch (error) {\n      console.error('Failed to parse WebSocket message:', error);\n    }\n  }\n\n  private handleWebSocketClose(): void {\n    if (this.reconnectAttempts < this.maxReconnectAttempts) {\n      this.reconnectAttempts++;\n      const delay = Math.pow(2, this.reconnectAttempts) * 1000; // Exponential backoff\n      \n      console.log(`Attempting to reconnect in ${delay}ms (attempt ${this.reconnectAttempts})`);\n      \n      setTimeout(() => {\n        if (this.sessionId) {\n          this.connectWebSocket(this.sessionId);\n        }\n      }, delay);\n    } else {\n      this.callbacks?.onError('Lost connection to AI backend');\n    }\n  }\n\n  // Send meeting events to backend\n  async sendMeetingEvent(eventType: string, data: any): Promise<void> {\n    if (!this.sessionId) {\n      console.warn('No active session to send event');\n      return;\n    }\n\n    try {\n      // Send via WebSocket for real-time processing\n      if (this.ws && this.ws.readyState === WebSocket.OPEN) {\n        this.ws.send(JSON.stringify({\n          type: 'meeting_event',\n          sessionId: this.sessionId,\n          eventType,\n          data,\n          timestamp: Date.now()\n        }));\n      }\n\n      // Also send via REST API for reliability\n      await fetch(`${API_BASE_URL}/api/meetings/events`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'Authorization': `Bearer ${this.getAuthToken()}`\n        },\n        body: JSON.stringify({\n          sessionId: this.sessionId,\n          eventType,\n          data,\n          timestamp: Date.now()\n        })\n      });\n    } catch (error) {\n      console.error('Failed to send meeting event:', error);\n    }\n  }\n\n  // Send participant updates\n  async updateParticipants(participants: any[]): Promise<void> {\n    await this.sendMeetingEvent('participants_update', { participants });\n  }\n\n  // Send transcript/conversation updates\n  async sendTranscriptUpdate(transcript: string): Promise<void> {\n    await this.sendMeetingEvent('transcript_update', { transcript });\n  }\n\n  // Send user interaction events\n  async sendUserInteraction(interaction: {\n    type: 'question_copied' | 'cue_applied' | 'ai_suggestion_used';\n    itemId: string;\n    metadata?: any;\n  }): Promise<void> {\n    await this.sendMeetingEvent('user_interaction', interaction);\n  }\n\n  // Close connection\n  async closeConnection(): Promise<void> {\n    if (this.ws) {\n      this.ws.close();\n      this.ws = null;\n    }\n    \n    if (this.sessionId) {\n      try {\n        await fetch(`${API_BASE_URL}/api/meetings/sessions/${this.sessionId}`, {\n          method: 'DELETE',\n          headers: {\n            'Authorization': `Bearer ${this.getAuthToken()}`\n          }\n        });\n      } catch (error) {\n        console.error('Failed to close session:', error);\n      }\n      \n      this.sessionId = null;\n    }\n  }\n\n  // Helper methods\n  private getAuthToken(): string {\n    // Get from localStorage, context, or environment\n    return localStorage.getItem('clarivue_auth_token') || 'demo-token';\n  }\n\n  private getUserId(): string {\n    // Get from user context or localStorage\n    return localStorage.getItem('clarivue_user_id') || 'demo-user';\n  }\n}\n\nexport const apiService = new APIService(); "],"mappings":"AAEA;AACA,MAAMA,YAAY,GAAGC,OAAO,CAACC,GAAG,CAACC,sBAAsB,IAAI,uBAAuB;AAClF,MAAMC,WAAW,GAAGH,OAAO,CAACC,GAAG,CAACG,qBAAqB,IAAI,qBAAqB;;AAE9E;;AA0BA,MAAMC,UAAU,CAAC;EAAAC,YAAA;IAAA,KACPC,EAAE,GAAqB,IAAI;IAAA,KAC3BC,SAAS,GAAwB,IAAI;IAAA,KACrCC,SAAS,GAAkB,IAAI;IAAA,KAC/BC,iBAAiB,GAAG,CAAC;IAAA,KACrBC,oBAAoB,GAAG,CAAC;EAAA;EAEhC;EACA,MAAMC,4BAA4BA,CAChCC,cAA8B,EAC9BL,SAAuB,EACN;IACjB,IAAI,CAACA,SAAS,GAAGA,SAAS;IAE1B,IAAI;MACF;MACA,MAAMM,eAAe,GAAG,MAAMC,KAAK,CAAC,GAAGhB,YAAY,wBAAwB,EAAE;QAC3EiB,MAAM,EAAE,MAAM;QACdC,OAAO,EAAE;UACP,cAAc,EAAE,kBAAkB;UAClC,eAAe,EAAE,UAAU,IAAI,CAACC,YAAY,CAAC,CAAC;QAChD,CAAC;QACDC,IAAI,EAAEC,IAAI,CAACC,SAAS,CAAC;UACnBC,QAAQ,EAAET,cAAc,CAACS,QAAQ;UACjCC,SAAS,EAAEV,cAAc,CAACW,EAAE;UAC5BC,WAAW,EAAEZ,cAAc,CAACa,IAAI;UAChCC,MAAM,EAAE,IAAI,CAACC,SAAS,CAAC,CAAC;UACxBC,SAAS,EAAEC,IAAI,CAACC,GAAG,CAAC;QACtB,CAAC;MACH,CAAC,CAAC;MAEF,IAAI,CAACjB,eAAe,CAACkB,EAAE,EAAE;QACvB,MAAM,IAAIC,KAAK,CAAC,kCAAkC,CAAC;MACrD;MAEA,MAAMC,OAAuB,GAAG,MAAMpB,eAAe,CAACqB,IAAI,CAAC,CAAC;MAC5D,IAAI,CAAC1B,SAAS,GAAGyB,OAAO,CAACzB,SAAS;;MAElC;MACA,MAAM,IAAI,CAAC2B,gBAAgB,CAACF,OAAO,CAACzB,SAAS,CAAC;MAE9C,OAAOyB,OAAO,CAACzB,SAAS;IAC1B,CAAC,CAAC,OAAO4B,KAAK,EAAE;MAAA,IAAAC,eAAA;MACdC,OAAO,CAACF,KAAK,CAAC,4CAA4C,EAAEA,KAAK,CAAC;MAClE,CAAAC,eAAA,OAAI,CAAC9B,SAAS,cAAA8B,eAAA,uBAAdA,eAAA,CAAgBE,OAAO,CAAC,iCAAiC,CAAC;MAC1D,MAAMH,KAAK;IACb;EACF;EAEA,MAAcD,gBAAgBA,CAAC3B,SAAiB,EAAiB;IAC/D,OAAO,IAAIgC,OAAO,CAAC,CAACC,OAAO,EAAEC,MAAM,KAAK;MACtC,IAAI;QACF,IAAI,CAACpC,EAAE,GAAG,IAAIqC,SAAS,CAAC,GAAGzC,WAAW,gBAAgBM,SAAS,UAAU,IAAI,CAACS,YAAY,CAAC,CAAC,EAAE,CAAC;QAE/F,IAAI,CAACX,EAAE,CAACsC,MAAM,GAAG,MAAM;UACrBN,OAAO,CAACO,GAAG,CAAC,kCAAkC,EAAErC,SAAS,CAAC;UAC1D,IAAI,CAACC,iBAAiB,GAAG,CAAC;UAC1BgC,OAAO,CAAC,CAAC;QACX,CAAC;QAED,IAAI,CAACnC,EAAE,CAACwC,SAAS,GAAIC,KAAK,IAAK;UAC7B,IAAI,CAACC,sBAAsB,CAACD,KAAK,CAAC;QACpC,CAAC;QAED,IAAI,CAACzC,EAAE,CAAC2C,OAAO,GAAIF,KAAK,IAAK;UAC3BT,OAAO,CAACO,GAAG,CAAC,mBAAmB,EAAEE,KAAK,CAACG,IAAI,EAAEH,KAAK,CAACI,MAAM,CAAC;UAC1D,IAAI,CAACC,oBAAoB,CAAC,CAAC;QAC7B,CAAC;QAED,IAAI,CAAC9C,EAAE,CAAC+C,OAAO,GAAIjB,KAAK,IAAK;UAC3BE,OAAO,CAACF,KAAK,CAAC,kBAAkB,EAAEA,KAAK,CAAC;UACxCM,MAAM,CAACN,KAAK,CAAC;QACf,CAAC;MACH,CAAC,CAAC,OAAOA,KAAK,EAAE;QACdM,MAAM,CAACN,KAAK,CAAC;MACf;IACF,CAAC,CAAC;EACJ;EAEQY,sBAAsBA,CAACD,KAAmB,EAAQ;IAAA,IAAAO,gBAAA,EAAAC,gBAAA,EAAAC,gBAAA,EAAAC,gBAAA,EAAAC,gBAAA;IACxD,IAAI;MACF,MAAMC,IAAI,GAAGxC,IAAI,CAACyC,KAAK,CAACb,KAAK,CAACY,IAAI,CAAC;MAEnC,QAAQA,IAAI,CAAClC,IAAI;QACf,KAAK,kBAAkB;UACrB,CAAA6B,gBAAA,OAAI,CAAC/C,SAAS,cAAA+C,gBAAA,uBAAdA,gBAAA,CAAgBO,iBAAiB,CAACF,IAAI,CAACG,OAAO,CAAC;UAC/C;QACF,KAAK,aAAa;UAChB,CAAAP,gBAAA,OAAI,CAAChD,SAAS,cAAAgD,gBAAA,uBAAdA,gBAAA,CAAgBQ,YAAY,CAACJ,IAAI,CAACG,OAAO,CAAC;UAC1C;QACF,KAAK,uBAAuB;UAC1B,CAAAN,gBAAA,OAAI,CAACjD,SAAS,cAAAiD,gBAAA,uBAAdA,gBAAA,CAAgBQ,qBAAqB,CAACL,IAAI,CAACG,OAAO,CAAC;UACnD;QACF,KAAK,sBAAsB;UACzB,CAAAL,gBAAA,OAAI,CAAClD,SAAS,cAAAkD,gBAAA,uBAAdA,gBAAA,CAAgBQ,oBAAoB,CAACN,IAAI,CAACG,OAAO,CAACI,KAAK,CAAC;UACxD;QACF,KAAK,OAAO;UACV,CAAAR,gBAAA,OAAI,CAACnD,SAAS,cAAAmD,gBAAA,uBAAdA,gBAAA,CAAgBnB,OAAO,CAACoB,IAAI,CAACG,OAAO,CAACK,OAAO,CAAC;UAC7C;QACF;UACE7B,OAAO,CAACO,GAAG,CAAC,uBAAuB,EAAEc,IAAI,CAAClC,IAAI,CAAC;MACnD;IACF,CAAC,CAAC,OAAOW,KAAK,EAAE;MACdE,OAAO,CAACF,KAAK,CAAC,oCAAoC,EAAEA,KAAK,CAAC;IAC5D;EACF;EAEQgB,oBAAoBA,CAAA,EAAS;IACnC,IAAI,IAAI,CAAC3C,iBAAiB,GAAG,IAAI,CAACC,oBAAoB,EAAE;MACtD,IAAI,CAACD,iBAAiB,EAAE;MACxB,MAAM2D,KAAK,GAAGC,IAAI,CAACC,GAAG,CAAC,CAAC,EAAE,IAAI,CAAC7D,iBAAiB,CAAC,GAAG,IAAI,CAAC,CAAC;;MAE1D6B,OAAO,CAACO,GAAG,CAAC,8BAA8BuB,KAAK,eAAe,IAAI,CAAC3D,iBAAiB,GAAG,CAAC;MAExF8D,UAAU,CAAC,MAAM;QACf,IAAI,IAAI,CAAC/D,SAAS,EAAE;UAClB,IAAI,CAAC2B,gBAAgB,CAAC,IAAI,CAAC3B,SAAS,CAAC;QACvC;MACF,CAAC,EAAE4D,KAAK,CAAC;IACX,CAAC,MAAM;MAAA,IAAAI,gBAAA;MACL,CAAAA,gBAAA,OAAI,CAACjE,SAAS,cAAAiE,gBAAA,uBAAdA,gBAAA,CAAgBjC,OAAO,CAAC,+BAA+B,CAAC;IAC1D;EACF;;EAEA;EACA,MAAMkC,gBAAgBA,CAACC,SAAiB,EAAEf,IAAS,EAAiB;IAClE,IAAI,CAAC,IAAI,CAACnD,SAAS,EAAE;MACnB8B,OAAO,CAACqC,IAAI,CAAC,iCAAiC,CAAC;MAC/C;IACF;IAEA,IAAI;MACF;MACA,IAAI,IAAI,CAACrE,EAAE,IAAI,IAAI,CAACA,EAAE,CAACsE,UAAU,KAAKjC,SAAS,CAACkC,IAAI,EAAE;QACpD,IAAI,CAACvE,EAAE,CAACwE,IAAI,CAAC3D,IAAI,CAACC,SAAS,CAAC;UAC1BK,IAAI,EAAE,eAAe;UACrBjB,SAAS,EAAE,IAAI,CAACA,SAAS;UACzBkE,SAAS;UACTf,IAAI;UACJ/B,SAAS,EAAEC,IAAI,CAACC,GAAG,CAAC;QACtB,CAAC,CAAC,CAAC;MACL;;MAEA;MACA,MAAMhB,KAAK,CAAC,GAAGhB,YAAY,sBAAsB,EAAE;QACjDiB,MAAM,EAAE,MAAM;QACdC,OAAO,EAAE;UACP,cAAc,EAAE,kBAAkB;UAClC,eAAe,EAAE,UAAU,IAAI,CAACC,YAAY,CAAC,CAAC;QAChD,CAAC;QACDC,IAAI,EAAEC,IAAI,CAACC,SAAS,CAAC;UACnBZ,SAAS,EAAE,IAAI,CAACA,SAAS;UACzBkE,SAAS;UACTf,IAAI;UACJ/B,SAAS,EAAEC,IAAI,CAACC,GAAG,CAAC;QACtB,CAAC;MACH,CAAC,CAAC;IACJ,CAAC,CAAC,OAAOM,KAAK,EAAE;MACdE,OAAO,CAACF,KAAK,CAAC,+BAA+B,EAAEA,KAAK,CAAC;IACvD;EACF;;EAEA;EACA,MAAM2C,kBAAkBA,CAACC,YAAmB,EAAiB;IAC3D,MAAM,IAAI,CAACP,gBAAgB,CAAC,qBAAqB,EAAE;MAAEO;IAAa,CAAC,CAAC;EACtE;;EAEA;EACA,MAAMC,oBAAoBA,CAACC,UAAkB,EAAiB;IAC5D,MAAM,IAAI,CAACT,gBAAgB,CAAC,mBAAmB,EAAE;MAAES;IAAW,CAAC,CAAC;EAClE;;EAEA;EACA,MAAMC,mBAAmBA,CAACC,WAIzB,EAAiB;IAChB,MAAM,IAAI,CAACX,gBAAgB,CAAC,kBAAkB,EAAEW,WAAW,CAAC;EAC9D;;EAEA;EACA,MAAMC,eAAeA,CAAA,EAAkB;IACrC,IAAI,IAAI,CAAC/E,EAAE,EAAE;MACX,IAAI,CAACA,EAAE,CAACgF,KAAK,CAAC,CAAC;MACf,IAAI,CAAChF,EAAE,GAAG,IAAI;IAChB;IAEA,IAAI,IAAI,CAACE,SAAS,EAAE;MAClB,IAAI;QACF,MAAMM,KAAK,CAAC,GAAGhB,YAAY,0BAA0B,IAAI,CAACU,SAAS,EAAE,EAAE;UACrEO,MAAM,EAAE,QAAQ;UAChBC,OAAO,EAAE;YACP,eAAe,EAAE,UAAU,IAAI,CAACC,YAAY,CAAC,CAAC;UAChD;QACF,CAAC,CAAC;MACJ,CAAC,CAAC,OAAOmB,KAAK,EAAE;QACdE,OAAO,CAACF,KAAK,CAAC,0BAA0B,EAAEA,KAAK,CAAC;MAClD;MAEA,IAAI,CAAC5B,SAAS,GAAG,IAAI;IACvB;EACF;;EAEA;EACQS,YAAYA,CAAA,EAAW;IAC7B;IACA,OAAOsE,YAAY,CAACC,OAAO,CAAC,qBAAqB,CAAC,IAAI,YAAY;EACpE;EAEQ7D,SAASA,CAAA,EAAW;IAC1B;IACA,OAAO4D,YAAY,CAACC,OAAO,CAAC,kBAAkB,CAAC,IAAI,WAAW;EAChE;AACF;AAEA,OAAO,MAAMC,UAAU,GAAG,IAAIrF,UAAU,CAAC,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}