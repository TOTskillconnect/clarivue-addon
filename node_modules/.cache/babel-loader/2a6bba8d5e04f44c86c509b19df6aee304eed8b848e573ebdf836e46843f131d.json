{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useState, useEffect, useCallback, useRef } from 'react';\nimport { apiService } from '../services/apiService';\nexport const useRealTimeAPI = ({\n  meetingContext,\n  fallbackToMockData = true\n}) => {\n  _s();\n  const [questions, setQuestions] = useState([]);\n  const [cues, setCues] = useState([]);\n  const [aiSuggestions, setAISuggestions] = useState([]);\n  const [meetingStage, setMeetingStage] = useState('start');\n  const [isConnected, setIsConnected] = useState(false);\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState(null);\n  const [connectionStatus, setConnectionStatus] = useState('disconnected');\n  const sessionIdRef = useRef(null);\n  const reconnectTimeoutRef = useRef(null);\n\n  // API callbacks for handling real-time updates\n  const apiCallbacks = {\n    onQuestionsUpdate: useCallback(newQuestions => {\n      setQuestions(newQuestions);\n    }, []),\n    onCuesUpdate: useCallback(newCues => {\n      setCues(newCues);\n    }, []),\n    onAISuggestionsUpdate: useCallback(newSuggestions => {\n      setAISuggestions(newSuggestions);\n    }, []),\n    onMeetingStageChange: useCallback(stage => {\n      setMeetingStage(stage);\n    }, []),\n    onError: useCallback(errorMessage => {\n      setError(errorMessage);\n      setConnectionStatus('error');\n      setIsConnected(false);\n    }, [])\n  };\n\n  // Initialize connection when meeting context is available\n  useEffect(() => {\n    if (!meetingContext) return;\n    const initializeConnection = async () => {\n      setIsLoading(true);\n      setConnectionStatus('connecting');\n      setError(null);\n      try {\n        const sessionId = await apiService.initializeRealTimeConnection(meetingContext, apiCallbacks);\n        sessionIdRef.current = sessionId;\n        setIsConnected(true);\n        setConnectionStatus('connected');\n        console.log('Real-time API connection established:', sessionId);\n      } catch (error) {\n        console.error('Failed to initialize real-time API:', error);\n        setError('Failed to connect to AI backend');\n        setConnectionStatus('error');\n        setIsConnected(false);\n\n        // Fallback to mock data if enabled\n        if (fallbackToMockData) {\n          console.log('Falling back to mock data');\n          loadMockData();\n        }\n      } finally {\n        setIsLoading(false);\n      }\n    };\n    initializeConnection();\n\n    // Cleanup on unmount or context change\n    return () => {\n      if (reconnectTimeoutRef.current) {\n        clearTimeout(reconnectTimeoutRef.current);\n      }\n      apiService.closeConnection();\n      setIsConnected(false);\n      setConnectionStatus('disconnected');\n    };\n  }, [meetingContext, fallbackToMockData]);\n\n  // Load mock data as fallback\n  const loadMockData = useCallback(() => {\n    // Import mock data functions\n    import('../utils/mockData').then(({\n      getQuestionsForMeeting,\n      getCuesForStage,\n      mockAISuggestions\n    }) => {\n      if (meetingContext) {\n        setQuestions(getQuestionsForMeeting(meetingContext.type, 'start'));\n        setCues(getCuesForStage('active'));\n        setAISuggestions(mockAISuggestions.slice(0, 3));\n        setMeetingStage('start');\n      }\n    });\n  }, [meetingContext]);\n\n  // Action functions\n  const sendUserInteraction = useCallback(async interaction => {\n    if (!isConnected) {\n      console.warn('Cannot send interaction - not connected to API');\n      return;\n    }\n    try {\n      await apiService.sendUserInteraction(interaction);\n    } catch (error) {\n      console.error('Failed to send user interaction:', error);\n    }\n  }, [isConnected]);\n  const updateParticipants = useCallback(async participants => {\n    if (!isConnected) return;\n    try {\n      await apiService.updateParticipants(participants);\n    } catch (error) {\n      console.error('Failed to update participants:', error);\n    }\n  }, [isConnected]);\n  const sendTranscriptUpdate = useCallback(async transcript => {\n    if (!isConnected) return;\n    try {\n      await apiService.sendTranscriptUpdate(transcript);\n    } catch (error) {\n      console.error('Failed to send transcript update:', error);\n    }\n  }, [isConnected]);\n  const reconnect = useCallback(async () => {\n    if (!meetingContext) return;\n    setIsLoading(true);\n    setConnectionStatus('connecting');\n    try {\n      await apiService.closeConnection();\n      const sessionId = await apiService.initializeRealTimeConnection(meetingContext, apiCallbacks);\n      sessionIdRef.current = sessionId;\n      setIsConnected(true);\n      setConnectionStatus('connected');\n      setError(null);\n    } catch (error) {\n      console.error('Reconnection failed:', error);\n      setError('Reconnection failed');\n      setConnectionStatus('error');\n    } finally {\n      setIsLoading(false);\n    }\n  }, [meetingContext]);\n  return {\n    questions,\n    cues,\n    aiSuggestions,\n    meetingStage,\n    isConnected,\n    isLoading,\n    error,\n    connectionStatus,\n    sendUserInteraction,\n    updateParticipants,\n    sendTranscriptUpdate,\n    reconnect\n  };\n};\n_s(useRealTimeAPI, \"Xrt/UI5CpWAua6JUbMRnK5oNndU=\");","map":{"version":3,"names":["useState","useEffect","useCallback","useRef","apiService","useRealTimeAPI","meetingContext","fallbackToMockData","_s","questions","setQuestions","cues","setCues","aiSuggestions","setAISuggestions","meetingStage","setMeetingStage","isConnected","setIsConnected","isLoading","setIsLoading","error","setError","connectionStatus","setConnectionStatus","sessionIdRef","reconnectTimeoutRef","apiCallbacks","onQuestionsUpdate","newQuestions","onCuesUpdate","newCues","onAISuggestionsUpdate","newSuggestions","onMeetingStageChange","stage","onError","errorMessage","initializeConnection","sessionId","initializeRealTimeConnection","current","console","log","loadMockData","clearTimeout","closeConnection","then","getQuestionsForMeeting","getCuesForStage","mockAISuggestions","type","slice","sendUserInteraction","interaction","warn","updateParticipants","participants","sendTranscriptUpdate","transcript","reconnect"],"sources":["/Users/tobitowoju/clarivue-addon/clarivue-addon/src/hooks/useRealTimeAPI.ts"],"sourcesContent":["import { useState, useEffect, useCallback, useRef } from 'react';\nimport { apiService, APICallbacks } from '../services/apiService';\nimport { Question, Cue, AISuggestion, MeetingContext } from '../utils/mockData';\n\ninterface UseRealTimeAPIOptions {\n  meetingContext: MeetingContext | null;\n  fallbackToMockData?: boolean;\n}\n\ninterface UseRealTimeAPIReturn {\n  questions: Question[];\n  cues: Cue[];\n  aiSuggestions: AISuggestion[];\n  meetingStage: 'start' | 'middle' | 'end';\n  isConnected: boolean;\n  isLoading: boolean;\n  error: string | null;\n  connectionStatus: 'connecting' | 'connected' | 'disconnected' | 'error';\n  \n  // Actions\n  sendUserInteraction: (interaction: {\n    type: 'question_copied' | 'cue_applied' | 'ai_suggestion_used';\n    itemId: string;\n    metadata?: any;\n  }) => Promise<void>;\n  updateParticipants: (participants: any[]) => Promise<void>;\n  sendTranscriptUpdate: (transcript: string) => Promise<void>;\n  reconnect: () => Promise<void>;\n}\n\nexport const useRealTimeAPI = ({ \n  meetingContext, \n  fallbackToMockData = true \n}: UseRealTimeAPIOptions): UseRealTimeAPIReturn => {\n  const [questions, setQuestions] = useState<Question[]>([]);\n  const [cues, setCues] = useState<Cue[]>([]);\n  const [aiSuggestions, setAISuggestions] = useState<AISuggestion[]>([]);\n  const [meetingStage, setMeetingStage] = useState<'start' | 'middle' | 'end'>('start');\n  const [isConnected, setIsConnected] = useState(false);\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState<string | null>(null);\n  const [connectionStatus, setConnectionStatus] = useState<'connecting' | 'connected' | 'disconnected' | 'error'>('disconnected');\n  \n  const sessionIdRef = useRef<string | null>(null);\n  const reconnectTimeoutRef = useRef<NodeJS.Timeout | null>(null);\n\n  // API callbacks for handling real-time updates\n  const apiCallbacks: APICallbacks = {\n    onQuestionsUpdate: useCallback((newQuestions: Question[]) => {\n      setQuestions(newQuestions);\n    }, []),\n    \n    onCuesUpdate: useCallback((newCues: Cue[]) => {\n      setCues(newCues);\n    }, []),\n    \n    onAISuggestionsUpdate: useCallback((newSuggestions: AISuggestion[]) => {\n      setAISuggestions(newSuggestions);\n    }, []),\n    \n    onMeetingStageChange: useCallback((stage: 'start' | 'middle' | 'end') => {\n      setMeetingStage(stage);\n    }, []),\n    \n    onError: useCallback((errorMessage: string) => {\n      setError(errorMessage);\n      setConnectionStatus('error');\n      setIsConnected(false);\n    }, [])\n  };\n\n  // Initialize connection when meeting context is available\n  useEffect(() => {\n    if (!meetingContext) return;\n\n    const initializeConnection = async () => {\n      setIsLoading(true);\n      setConnectionStatus('connecting');\n      setError(null);\n\n      try {\n        const sessionId = await apiService.initializeRealTimeConnection(\n          meetingContext,\n          apiCallbacks\n        );\n        \n        sessionIdRef.current = sessionId;\n        setIsConnected(true);\n        setConnectionStatus('connected');\n        \n        console.log('Real-time API connection established:', sessionId);\n      } catch (error) {\n        console.error('Failed to initialize real-time API:', error);\n        setError('Failed to connect to AI backend');\n        setConnectionStatus('error');\n        setIsConnected(false);\n        \n        // Fallback to mock data if enabled\n        if (fallbackToMockData) {\n          console.log('Falling back to mock data');\n          loadMockData();\n        }\n      } finally {\n        setIsLoading(false);\n      }\n    };\n\n    initializeConnection();\n\n    // Cleanup on unmount or context change\n    return () => {\n      if (reconnectTimeoutRef.current) {\n        clearTimeout(reconnectTimeoutRef.current);\n      }\n      apiService.closeConnection();\n      setIsConnected(false);\n      setConnectionStatus('disconnected');\n    };\n  }, [meetingContext, fallbackToMockData]);\n\n  // Load mock data as fallback\n  const loadMockData = useCallback(() => {\n    // Import mock data functions\n    import('../utils/mockData').then(({ \n      getQuestionsForMeeting, \n      getCuesForStage, \n      mockAISuggestions \n    }) => {\n      if (meetingContext) {\n        setQuestions(getQuestionsForMeeting(meetingContext.type, 'start'));\n        setCues(getCuesForStage('active'));\n        setAISuggestions(mockAISuggestions.slice(0, 3));\n        setMeetingStage('start');\n      }\n    });\n  }, [meetingContext]);\n\n  // Action functions\n  const sendUserInteraction = useCallback(async (interaction: {\n    type: 'question_copied' | 'cue_applied' | 'ai_suggestion_used';\n    itemId: string;\n    metadata?: any;\n  }) => {\n    if (!isConnected) {\n      console.warn('Cannot send interaction - not connected to API');\n      return;\n    }\n    \n    try {\n      await apiService.sendUserInteraction(interaction);\n    } catch (error) {\n      console.error('Failed to send user interaction:', error);\n    }\n  }, [isConnected]);\n\n  const updateParticipants = useCallback(async (participants: any[]) => {\n    if (!isConnected) return;\n    \n    try {\n      await apiService.updateParticipants(participants);\n    } catch (error) {\n      console.error('Failed to update participants:', error);\n    }\n  }, [isConnected]);\n\n  const sendTranscriptUpdate = useCallback(async (transcript: string) => {\n    if (!isConnected) return;\n    \n    try {\n      await apiService.sendTranscriptUpdate(transcript);\n    } catch (error) {\n      console.error('Failed to send transcript update:', error);\n    }\n  }, [isConnected]);\n\n  const reconnect = useCallback(async () => {\n    if (!meetingContext) return;\n    \n    setIsLoading(true);\n    setConnectionStatus('connecting');\n    \n    try {\n      await apiService.closeConnection();\n      const sessionId = await apiService.initializeRealTimeConnection(\n        meetingContext,\n        apiCallbacks\n      );\n      \n      sessionIdRef.current = sessionId;\n      setIsConnected(true);\n      setConnectionStatus('connected');\n      setError(null);\n    } catch (error) {\n      console.error('Reconnection failed:', error);\n      setError('Reconnection failed');\n      setConnectionStatus('error');\n    } finally {\n      setIsLoading(false);\n    }\n  }, [meetingContext]);\n\n  return {\n    questions,\n    cues,\n    aiSuggestions,\n    meetingStage,\n    isConnected,\n    isLoading,\n    error,\n    connectionStatus,\n    sendUserInteraction,\n    updateParticipants,\n    sendTranscriptUpdate,\n    reconnect\n  };\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}